<html>
    <meta charset="UTF-8">
    <head>
	<!-- WebGL Dependencies -->
	<script type="text/javascript" src="js/deckgl.min.js"></script>

	<!-- GUI Dependencies -->
	<script type="text/javascript" src="js/react.min.js"> </script>
	<script type="text/javascript" src="js/react-dom.min.js"></script>
	<script type="text/javascript" src="js/babel.min.js"></script>
	
	<!-- IO Dependencies -->
	<script type="text/javascript" src="js/d3.min.js"></script>
	<script type="text/javascript" src="js/pako_inflate.min.js"></script>
    </head>

    <style>
     body {
	 width: 100vw;
	 height: 100vh;
	 margin: 0;
	 background: #111;
     }

     #loading {
	 position: absolute;
	 width: 100px;
	 height: 100px;
	 z-index: 15;
	 top: 50%;
	 left: 50%;
	 margin: -100px 0 0 -100px;	 
     }

     #control-panel {
	 /*border: 1px solid black;*/
	 font-family: Helvetica, Arial, sans-serif;
	 position: absolute;
	 background-color: rgba(255, 255, 255, 0.9);
	 top: 0;
	 left: 0;
	 margin: 20px;
	 padding: 15px 20px;;
	 z-index: 1;
	 border-radius: 20px;
     }

     label {
	 display: inline-block;
	 width: 140px;
     }

     #tooltip:empty {
	 display: none;
     }
     #tooltip {
	 font-family: Helvetica, Arial, sans-serif;
	 font-size: 11px;
	 position: absolute;
	 padding: 4px;
	 margin: 8px;
	 background: rgba(0, 0, 0, 0.8);
	 color: #fff;
	 max-width: 300px;
	 font-size: 10px;
	 z-index: 9;
	 pointer-events: none;
     }
     
    </style>
    
    </head>

    <body>
	<div id="tooltip"></div>
	<div id="loading"><img src="loading.gif"></div>
	
	<div id="control-panel">
	    <div id='control-panel-stats'>
		<label>Total Points Rendered</label>
		<span id='totalPoints'></span>
	    </div>
	    <hr>
	    <div id='control-panel-fixed-options'>
		<label>Size</label>
		<input id="radiusScale" type="range" min="0.1" max="5" step="0.1" value="0.5"></input>
		<span id="radiusScale-value"></span>
	    </div>
	    <span id="control-panel-detected-options">
	    </span>
	    <hr>
	    <div id='control-panel-buttons'>
		<button id='reset'>Reset View</button>
		<a href="data.csv.gz"><button>Download Data</button></a>
		<a href="https://github.com/JEFworks/MERmaid"><button>Source Code</button></a>
	    </div>
	</div>

    </body>
    
    <script type="text/babel">     
     // Create selection menu for detected options
     function renderTable(genes, div) {
	 var divid = div + '_holder';
	 class Table extends React.Component {	 
	     render() {
		 return (
		     <div>
			 <label>{div}</label>
			 <select id={div}>
			     {genes.map((i) => {
				   return (<option value={i}>{i}</option>)
			       })}
			 </select>
		     </div>
		 )
	     }
	 };
	 ReactDOM.render(
	     <Table />,
	     document.getElementById(divid)
	 );
     }
    </script>

    <script type="text/javascript">

     // File reader
     var logTime = function(text) {
	 console.log('[' + new Date().toUTCString() + '] ' + text);
     }
     var fetch = function(data_url, callback) {
	 logTime('downloading data');
	 var oReq = new XMLHttpRequest();
	 oReq.open("GET", data_url, true);
	 oReq.responseType = "arraybuffer";
	 oReq.onload = function(oEvent) {
	     var arrayBuffer = oReq.response;
	     if (arrayBuffer) {		 
		 var byteArray = new Uint8Array(arrayBuffer); // Get the compressed data		 
		 byteArray = pako.inflate(byteArray) // Decompress the data
		 var s = new TextDecoder("utf-8").decode(byteArray) // Convert to string
		 callback(s)
	     }
	 };
	 oReq.send(null);
     }

     // DeckGL
     const deckgl = new deck.DeckGL({
	 views: [new deck.OrbitView({
	     controller: {
		 dragRotate: false,
		 dragPan: true
	     }
	 })],
	 viewState: {fov: 50, distance: 100, rotationX: 0, rotationOrbit: 0, zoom: 1},
     });

     // Controllers
     const fixed_options = ['radiusScale'];   
     fixed_options.forEach(key => {
	 document.getElementById(key).oninput = renderLayer;
     });     
     d3.select('#reset').on('click', d => {
	 console.log('reset view');
	 deckgl.setProps({
	     viewState: {fov: 50, distance: 100, rotationX: 0, rotationOrbit: 0, zoom: 1}
	 })
     });

     const colors = [
	 [255, 0, 0, 255],
	 [0, 255, 0, 255],
	 [0, 0, 255, 255],
	 [0, 255, 255, 255],
	 [255, 255, 0, 255]
     ];

     function fac2col(d) {
	 if(d[2] === detected_options_selected[detected_options[0]]) {
	     return(colors[0])
	 } else if ( d[3] === detected_options_selected[detected_options[1]] ) {
	     return(colors[1])	     
	 } else {
	     return([255, 255, 255, 100])
	 }
     }
     
     var fixed_options_selected = {};	 
     var detected_options_selected = {};
     function renderLayer () {
	 
	 fixed_options.forEach(key => {
	     const value = document.getElementById(key).value;
	     document.getElementById(key + '-value').innerHTML = value;
	     fixed_options_selected[key] = Number(value);
	 });
	 console.log(fixed_options_selected);

	 detected_options.forEach(key => {
	     var value = document.getElementById(key).value;
	     detected_options_selected[key] = value;
	 });	     
	 console.log(detected_options_selected);
	 var option_change_trigger = Object.values(detected_options_selected).join();
	 
	 var scatterplotLayer = new
	 deck.ScatterplotLayer({
	     id: 'MERmaid',
	     data: data,
	     coordinateSystem: deck.COORDINATE_SYSTEM.IDENTITY,
	     getPosition: d => [parseFloat(d[header.indexOf('x')]), parseFloat(d[header.indexOf('y')]), parseFloat(d[header.indexOf('z')])],
	     getNormal: d => [0, 1, 0],
	     getColor: fac2col,
	     getRadius: d => (d[2]===detected_options_selected[detected_options[0]] | d[3]===detected_options_selected[detected_options[1]] ? 4 : 1),
	     radiusMinPixels: 0.1,
	     radiusMaxPixels: 10,

	     lightSettings: {
		 coordinateSystem: deck.COORDINATE_SYSTEM.IDENTITY,
		 lightsPosition: [20, 100, 100, 50, 0, 0],
		 lightsStrength: [1, 0, 2, 0],
		 numberOfLights: 2,
		 ambientRatio: 0.2
	     },
	     
	     pickable: true,
	     onHover: updateTooltip,

	     updateTriggers: {
		 getColor: option_change_trigger,
		 getRadius: option_change_trigger
	     },
	     
	     ...fixed_options_selected
	 })

	 deckgl.setProps({
	     layers: [scatterplotLayer]
	 });

     }   

     function updateTooltip({x, y, object}) {
	 const tooltip = document.getElementById('tooltip');

	 if (object) {
	     tooltip.style.top = `${y}px`;
	     tooltip.style.left = `${x}px`;
	     tooltip.innerHTML = `
		 <div><div>${object[2]}</div></div>
		 `;
	 } else {
	     tooltip.innerHTML = '';
	 }
     }

     // Read data
     const DATA_URL = 'data.csv.gz';
     var header = [];
     var detected_options = [];
     fetch(DATA_URL, function(data_string) {
	 logTime('parsing data');
	 data = d3.csvParseRows(
	     data_string,
	     (d, i) => {
		 return(d)
	     }
	 )
	 header = data.splice(0,1)[0];

	 // Automatically fill in options
	 detected_options = header.filter(x => ['x', 'y', 'z'].indexOf(x) < 0 );
	 console.log(detected_options)
         var ops = [];
	 var detected_options_selected = [];
	 d3.map(detected_options, function(option) {
	     ops = []; 
	     var j = header.indexOf(option);
	     for (var i = 0; i < data.length; i++) {
                 if (data[i][j] in ops) {
		     ops[data[i][j]]++;
		 } else {
		     ops[data[i][j]] = 1;
		 }
	     }
	     ops = Object.keys(ops);
	     iDiv = document.createElement('div');
	     iDiv.id = option + '_holder';
	     document.getElementById('control-panel-detected-options').appendChild(iDiv);	     
	     renderTable(ops, option);

	     document.getElementById(option).onchange = renderLayer;   
	 });

	 // Render
	 logTime('started rendering layer');
	 renderLayer();
	 logTime('finished rendering layer');

	 // Fill in stats
	 document.getElementById('totalPoints').innerHTML = d3.format(",")(data.length);

	 // Remove loading
	 document.getElementById('loading').innerHTML = ''; 
     })

    </script>
    
</html>
